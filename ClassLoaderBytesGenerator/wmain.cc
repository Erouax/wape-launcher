#include <ctime>
#include <Windows.h>
#include <iostream>
#include <fstream>
#include <random>
#include <unordered_map>
#include "miniz.h"
#include "zip_file.h"
#include "pcg32.h"
#include "cx_crc32.h"
#include <iomanip>

constexpr const auto kMaxSectionNameLength = 7u;
constexpr const auto kMaxSegments = 8u;

#pragma region Random Number Generator
std::tr1::minstd_rand* g_random_gen = nullptr;

void InitializeRandomGenerator() {
  g_random_gen = new std::tr1::minstd_rand;
  g_random_gen->seed(static_cast<unsigned>(time(nullptr)));
}

void ReleaseRandomGenerator() {
  delete g_random_gen;
  g_random_gen = nullptr;
}

uint64_t GenerateRandom() {
  if (!g_random_gen) {
    return 0;
  }
  std::tr1::uniform_int<uint64_t> unif(1, -1LL);;
  return unif(*g_random_gen);
}

std::wstring GenerateString(const size_t length) {
  if (!g_random_gen) {
    return {};
  }
  constexpr const char dictionary[] =
    "abcdefghijklmnopqrstuvwxyz"
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    "0123456789";
  std::wstring str;
  str.reserve(length);
  for (auto iii = size_t{ 0 }; iii < length; iii++) {
    str.append(
      sizeof(char),
      dictionary[GenerateRandom() % (sizeof(dictionary) - 1)]);
  }
  return str;
}
#pragma endregion

#pragma region General
bool ReadFileInfoBuffer(const wchar_t* file_name,
                        uint8_t** buffer,
                        size_t* length) {
  if (!file_name || !buffer || !length) {
    return false;
  }

  // open file for binary
  // starting from the end to grab the size right away
  auto file_stream = std::basic_ifstream<uint8_t>{ file_name, std::ios::in |
    std::ios::binary |
    std::ios::ate };
  if (!file_stream.is_open()) {
    return false;
  }

  // grab total size of the file and reset position
  *length = file_stream.tellg();
  file_stream.seekg(0, std::ios::beg);

  // allocate memory to store the encrypted data
  *buffer = new uint8_t[*length];

  // copy the file contents to the newly allocated buffer
  file_stream.read(*buffer, *length);

  // finally close the used resources
  file_stream.close();
  return true;
}

bool EncryptFileContents(const wchar_t* file_name,
  uint64_t* seed,
  uint8_t** buffer,
  size_t* length) {
  if (!file_name || !seed || !buffer || !length) {
    return false;
  }

  if (!ReadFileInfoBuffer(file_name, buffer, length)) {
    return false;
  }

  // generate seed as key for the xor operation
  *seed = GenerateRandom();

  // xor each input byte with key generated by pcg32 algo
  pcg32 rnd(*seed);
  for (auto iii = 0u; iii < *length; iii++) {
    rnd.advance(iii + 1);
    (*buffer)[iii] ^= rnd.nextUInt() >> 24;
  }

  return true;
}
#pragma endregion

#pragma region Class File Packer
int PackClassFile(wchar_t* file) {
  auto seed = uint64_t{ 0 };
  auto length = size_t{ 0 };
  uint8_t* buffer = nullptr;
  if (!EncryptFileContents(file, &seed, &buffer, &length)) {
    std::wcout << L"The file \""
      << file
      << "\" does not exist" << std::endl;
    return 1;
  }

  /* - compression doens't work when you XOR the whole fucking thing
  auto compressed_length = size_t{ 0 };
  auto compressed_buffer = static_cast<uint8_t*>(tdefl_compress_mem_to_heap(
    buffer,
    length,
    &compressed_length,
    TDEFL_DEFAULT_MAX_PROBES));

  delete[] buffer;
  buffer = nullptr;

  if (!compressed_buffer) {
    std::cout << "An error occurred compressing the data" << std::endl;
    return 1;
  }
  */

  auto compressed_length = length;
  auto compressed_buffer = buffer;

  auto file_name = file;
  // start file name after the last back slash
  auto tmp = wcsrchr(file, '\\');
  if (tmp) {
    file_name = tmp + 1;
  }
  // null terminate the string starting from the file extension
  if ((tmp = const_cast<wchar_t*>(wcsrchr(file, '.')))) {
    *tmp = '\0';
  }

  std::wcout
    << L"constexpr const char kClassLoaderKlassName = \""
    << file_name
    << L"\";"
    << std::endl;

  std::cout
    << "constexpr const uint64_t kClassLoaderEncryptionSeed = "
    << seed
    << ";"
    << std::endl;

  std::cout << "const uint8_t kClassLoaderBytes[] = { ";
  std::cout << std::hex;
  for (auto iii = size_t{ 0 }; iii < compressed_length; iii++) {
    std::cout << "0x" << static_cast<int>(compressed_buffer[iii]);
    if (iii != (compressed_length - 1)) {
      std::cout << ", ";
    }
  }
  std::cout << " };" << std::endl;
  std::cin.get();

  // free(compressed_buffer);
  delete[] buffer;
  buffer = nullptr;
  return 0;
}
#pragma endregion

#pragma region Jar File Packer
constexpr const uint32_t kTerminator = 0xDEADC0DE;

#pragma pack(push, 1)
struct EncryptedZipEntryEntry {
  uint32_t name_length;
  uint64_t name_seed;
  uint32_t data_length;
  uint64_t data_seed;
};
#pragma pack(pop)

int PackZipFile(wchar_t* file_name) {
  // start by mapping the zip file to name -> bytes
  ZipFile zip(file_name);
  if (!zip.Good()) {
    std::wcout << L"The file \""
      << file_name
      << "\" does not exist" << std::endl;
    return false;
  }

  auto decompressed_jar =
    std::unordered_map<std::string, std::vector<uint8_t>>{};

  zip.ForEach([&](const auto& file)
  {
    if (!file.is_directory) {
      decompressed_jar.insert(std::make_pair(file.file_name, zip.Read(file)));
    }
    return true;
  });
  zip.Reset();

  // calculate the total size needed to store the header and data
  auto total_bytes = size_t{ (decompressed_jar.size() + 1) *
                             sizeof(EncryptedZipEntryEntry) };
  for (const auto& entry : decompressed_jar) {
    total_bytes += entry.first.length(); // length of string
    total_bytes += entry.second.size(); // length of class data
  }

  // allocate a buffer to store the data
  auto buffer = new uint8_t[total_bytes];

  // copy the map contents to our custom structure
  auto ptr = buffer;
  EncryptedZipEntryEntry* encrypted_zip_entry;
  pcg32 rnd;
  for (const auto& entry : decompressed_jar) {
    auto& name = entry.first;
    auto& bytes = entry.second;

    encrypted_zip_entry = reinterpret_cast<EncryptedZipEntryEntry*>(ptr);
    encrypted_zip_entry->name_length = static_cast<uint32_t>(name.length());
    encrypted_zip_entry->name_seed = GenerateRandom();
    encrypted_zip_entry->data_length = static_cast<uint32_t>(bytes.size());
    encrypted_zip_entry->data_seed = GenerateRandom();

    // move past the header to store the content
    ptr += sizeof(EncryptedZipEntryEntry);

    // xor and copy the name first
    rnd.seed(encrypted_zip_entry->name_seed);
    for (auto iii = size_t{0}; iii < name.length(); iii++) {
      rnd.advance(iii + 1);
      *ptr++ = name[iii] ^ rnd.nextUInt() >> 24;
    }

    // followed by the actual class data
    rnd.seed(encrypted_zip_entry->data_seed);
    for (auto iii = size_t{ 0 }; iii < bytes.size(); iii++) {
      rnd.advance(iii + 1);
      *ptr++ = bytes[iii] ^ rnd.nextUInt() >> 24;
    }
  }
  // add terminator
  encrypted_zip_entry = reinterpret_cast<EncryptedZipEntryEntry*>(ptr);
  encrypted_zip_entry->name_length = kTerminator;
  encrypted_zip_entry->name_seed = kTerminator;
  encrypted_zip_entry->data_length = kTerminator;
  encrypted_zip_entry->data_seed = kTerminator;


  /* - compression doens't work when you XOR the whole fucking thing
  // compress the whole chunk of data
  auto compressed_length = size_t{ 0 };
  auto compressed_buffer = static_cast<uint8_t*>(tdefl_compress_mem_to_heap(
    buffer,
    total_bytes,
    &compressed_length,
    TDEFL_DEFAULT_MAX_PROBES));

  // release the previous buffer as we no longer have a need for it
  delete[] buffer;
  buffer = nullptr;

  if (!compressed_buffer) {
    std::cout << "An error occurred compressing the data" << std::endl;
    return 1;
  }
  */

  auto compressed_length = total_bytes;
  auto compressed_buffer = buffer;

  pcg32 rng(GetTickCount64());

  // write data to segments
  const auto bytes_per_segment = compressed_length / kMaxSegments;
  auto written = size_t{ 0 };
  for (auto iii = 0u; iii < kMaxSegments; iii++) {
    // write the transformed data to disk
    const auto section_name = GenerateString(rng.nextUInt() % (kMaxSectionNameLength - 3) + 3);
    const auto out_file = /*std::wstring(file_name) + L".bin." +*/ section_name;
    auto output = std::basic_ofstream<uint8_t>(out_file, std::ios::out |
      std::ios::binary);
    if (!output.is_open()) {
      std::cout << "An error occurred writing the data" << std::endl;
      //free(compressed_buffer);
      delete[] buffer;
      return 1;
    }
    const auto to_write = (iii != (kMaxSegments - 1))
      ? bytes_per_segment
      : compressed_length - written;
    output.write(reinterpret_cast<const uint8_t*>(&to_write), sizeof(uint32_t));
    output.write(compressed_buffer + written, to_write);
    written += to_write;
    output.close();

    const auto hash = cx::crc32(section_name.data(), section_name.length());
    std::wcout
      << std::setw(3) << iii
      << std::setw(20) << section_name
      << std::setw(20) << L"0x" << std::hex << hash << L","
      << std::endl;
  }

  // and finally free up the used resources
  // free(compressed_buffer);
  delete[] buffer;
  return 0;
}
#pragma endregion

#pragma region File Packer
int PackFile(wchar_t* file_name) {
  auto seed = uint64_t{0};
  auto length = size_t{0};
  uint8_t* buffer = nullptr;
  if (!EncryptFileContents(file_name, &seed, &buffer, &length)) {
    std::wcout << L"The file \""
      << file_name
      << "\" does not exist" << std::endl;
    return 1;
  }

  std::cout
    << "constexpr const uint64_t kSegmentEncryptionSeed = 0x"
    << std::hex << seed
    << ";"
    << std::endl;

  std::cout << "constexpr const uint32_t kSegmentFileChunkMap[] = {" << std::endl;

  pcg32 rng(GetTickCount64());

  // write data to segments
  const auto bytes_per_segment = length / kMaxSegments;
  auto written = size_t{0};
  for (auto iii = 0u; iii < kMaxSegments; iii++) {
    // write the transformed data to disk
    const auto section_name = GenerateString(rng.nextUInt() % (kMaxSectionNameLength - 3) + 3);
    const auto out_file = /*std::wstring(file_name) + L".bin." +*/ section_name;

    auto output = std::basic_ofstream<uint8_t>(out_file, std::ios::out |
                                                         std::ios::binary);
    if (!output.is_open()) {
      std::cout << "An error occurred writing the data" << std::endl;
      //free(compressed_buffer);
      delete[] buffer;
      return 1;
    }

    const auto to_write = (iii != (kMaxSegments - 1))
      ? bytes_per_segment
      : length - written;

    const auto size = static_cast<const uint32_t>(to_write);
    output.write(reinterpret_cast<const uint8_t*>(&size), sizeof(size));
    
    output.write(buffer + written, to_write);
    written += to_write;
    output.close();

    const auto hash = cx::crc32(section_name.data(), section_name.length());
    std::cout << "  0x" << std::hex << hash;
    if (iii != (kMaxSegments - 1)) {
      std::cout << ",";
    }
    std::cout << std::endl;
  }
  std::cout << "};" << std::endl;

  delete[] buffer;
  return 0;
}
#pragma endregion

void PrintUsage(const wchar_t* program) {
  std::wcout << L"Usage: "
    << program
    << " [class|zip|file] [args...]"
    << std::endl;
}

int wmain(int argc, wchar_t* argv[], wchar_t* envp[]) {
  if (argc < 3) {
    PrintUsage(argv[0]);
    return 1;
  }

  auto result = 0;
  srand(static_cast<unsigned>(time(nullptr)));
  InitializeRandomGenerator();

  const auto test = GenerateString(7);

  if (!wcscmp(argv[1], L"class")) {
    result = PackClassFile(argv[2]);
  } else if (!wcscmp(argv[1], L"zip")) {
    result = PackZipFile(argv[2]);
  } else if (!wcscmp(argv[1], L"file")) {
    result = PackFile(argv[2]);
  } else {
    PrintUsage(argv[0]);
    result = 1;
  }

  ReleaseRandomGenerator();
  return result;
}
